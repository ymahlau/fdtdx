# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/170z6BWVRkYnTz3v-SKjuNuMvkJtmLYpc
"""

import jax
import jax.numpy as jnp
import numpy as np

from fdtdx.core.jax.pytrees import autoinit, frozen_field
from fdtdx.core.plotting.colors import ORANGE
from fdtdx.core.wavelength import WaveCharacter
from fdtdx.objects.sources.profile import SingleFrequencyProfile, TemporalProfile
from fdtdx.objects.sources.source import Source


@autoinit
class DipoleSource(Source):
    """A point dipole source for FDTD simulations.

    Attributes:
        polarization (tuple[float, float, float]): Direction of the dipole moment.
            Should be a unit vector. Defaults to (1, 0, 0) for x-polarization.
        amplitude (float): Amplitude of the dipole moment. Defaults to 1.0.
        wave_character (WaveCharacter): Wavelength and phase characteristics.
        temporal_profile (TemporalProfile): Temporal variation of the source.
            Defaults to SingleFrequencyProfile.
        static_amplitude_factor (float): Static scaling factor for amplitude.
        switch (OnOffSwitch): Controls when the source is active.
        color (tuple[float, float, float] | None): RGB color for visualization.
    """

    polarization: tuple[float, float, float] = frozen_field(default=(1.0, 0.0, 0.0))
    amplitude: float = frozen_field(default=1.0)

    def __post_init__(self):
        """Post-initialization to set default grid shape for dipole source."""
        # Set default grid shape - will be updated later when config is available
        # Default to small region for now
        dipole_shape = (3, 3, 3)

        # Set the grid shape for the dipole source
        if hasattr(self, 'partial_grid_shape') and self.partial_grid_shape != dipole_shape:
            object.__setattr__(self, 'partial_grid_shape', dipole_shape)

    def _normalize_polarization(self) -> jax.Array:
        """Normalize the polarization vector to unit length.

        Returns:
            jax.Array: Normalized polarization vector as (3,) array.
        """
        pol = jnp.asarray(self.polarization, dtype=jnp.float32)
        norm = jnp.linalg.norm(pol)
        # Avoid division by zero
        default_pol = jnp.asarray([1.0, 0.0, 0.0], dtype=jnp.float32)
        # Use jnp.where with proper broadcasting
        normalized = jnp.where(norm > 1e-10, pol / norm, default_pol)
        return jnp.asarray(normalized, dtype=jnp.float32)

    def place_on_grid(
        self,
        grid_slice_tuple: tuple[tuple[int, int], tuple[int, int], tuple[int, int]],
        config,
        key: jax.Array,
      ):
        s_x0, s_x1 = grid_slice_tuple[0]
        s_y0, s_y1 = grid_slice_tuple[1]
        s_z0, s_z1 = grid_slice_tuple[2]

        gx = (s_x0 + s_x1) // 2
        gy = (s_y0 + s_y1) // 2
        gz = (s_z0 + s_z1) // 2

        grid_pos = (gx, gy, gz)
        dipole_slice = tuple((gp, gp + 1) for gp in grid_pos)
        self = super().place_on_grid(
            grid_slice_tuple=dipole_slice,
            config=config,
            key=key,
        )
        self = self.aset("_grid_position", grid_pos, create_new_ok=True)
        return self

    def update_E(
        self,
        E: jax.Array,
        inv_permittivities: jax.Array,
        inv_permeabilities: jax.Array | float,
        time_step: jax.Array,
        inverse: bool,
    ) -> jax.Array:
        """Update the electric field with dipole source contribution.

        The dipole source contributes to the electric field through the displacement
        current. In the FDTD scheme, this is implemented as a source term in the
        curl equation for the electric field.

        Args:
            E (jax.Array): Current electric field array (3, nx, ny, nz).
            inv_permittivities (jax.Array): Inverse permittivity values.
            inv_permeabilities (jax.Array | float): Inverse permeability values.
            time_step (jax.Array): Current simulation time step.
            inverse (bool): Whether to perform inverse update for backpropagation.

        Returns:
            jax.Array: Updated electric field array.
        """
        if inverse:
            return E

        delta_t = self._config.time_step_duration
        time_t = time_step * delta_t
        amplitude_t = self.temporal_profile.get_amplitude(
            time=time_t,
            period=self.wave_character.get_period(),
            phase_shift=self.wave_character.phase_shift,
        )
        magnitude = amplitude_t * self.static_amplitude_factor
        pol = self._normalize_polarization()
        E_update = pol[:, None, None, None] * magnitude

        E = E.at[:, *self.grid_slice].add(E_update.astype(E.dtype))
        #(soft source)
        return E

    def update_H(
        self,
        H: jax.Array,
        inv_permittivities: jax.Array,
        inv_permeabilities: jax.Array | float,
        time_step: jax.Array,
        inverse: bool,
    ) -> jax.Array:
        """Args:
            H (jax.Array): Current magnetic field array (3, nx, ny, nz).
            inv_permittivities (jax.Array): Inverse permittivity values.
            inv_permeabilities (jax.Array | float): Inverse permeability values.
            time_step (jax.Array): Current simulation time step.
            inverse (bool): Whether to perform inverse update for backpropagation.

        Returns:
            jax.Array: Updated magnetic field array.
        """
        #(electric dipole so we don't update H here)
        return H